import { createContext, forwardRef, useRef, useState, useImperativeHandle, useEffect, createElement, Fragment, useContext, Children, useLayoutEffect } from 'react';
import { createPortal } from 'react-dom';

// $FlowFixMe
const MapContext = createContext(null);

const warnOnce = (() => {
  const map = {};
  return str => {
    if (map[str] == null) {
      map[str] = true;
      console.warn(str.replace(/^\s+/gm, ''));
    }
  };
})();

const STYLE = {
  width: '100%',
  height: '100%'
};
const Map = forwardRef(({
  api,
  options,
  children
}, ref) => {
  const element = useRef(null);
  const firstTimeRef = useRef(true);
  const [ctx, setCtx] = useState(null);

  if (process.env.NODE_ENV !== 'production') {
    // eslint-disable-next-line react-hooks/rules-of-hooks
    const apiRef = useRef(api); // eslint-disable-next-line react-hooks/rules-of-hooks

    const optionsRef = useRef(options);

    if (apiRef.current !== api) {
      warnOnce(`
          "api" prop of <Map> element has changed.

          If it's desired behaviour please remount your component
          using key={hash(api)} on your component.
        `); // Reinit map in case user has changed loader in dev

      firstTimeRef.current = true;
    } // JSON.stringify to work with React Refresh well


    if (typeof options !== 'function' && JSON.stringify(optionsRef.current) !== JSON.stringify(options)) {
      warnOnce(`
          "options" prop of <Map> element has changed.
          This change doesn't somehow affect map options at production.

          If it's desired behaviour please use imperative api, i.e. map.setOptions({...blabla});
        `); // Reinit map in case user changed options to find proper option

      firstTimeRef.current = true;
    }
  }

  useImperativeHandle(ref, () => ctx ? ctx.map : null, [ctx]);
  useEffect(() => {
    if (firstTimeRef.current && element.current) {
      const map = new api.Map(element.current, // We clone options object because Google adding new fields into it
      // this is not an expected behaviour in modern world ;-)
      { ...(typeof options === 'function' ? options(element.current) : options)
      });
      firstTimeRef.current = false;
      setCtx({
        map,
        api
      });
      return () => {};
    }
  }, [api, options]);
  return /*#__PURE__*/createElement(Fragment, null, /*#__PURE__*/createElement("div", {
    style: STYLE,
    ref: element
  }), ctx && /*#__PURE__*/createElement(MapContext.Provider, {
    value: ctx
  }, children));
});
const useMap = () => useContext(MapContext);

const Marker = props => {
  return props.children;
};
const Overlay = props => {
  const {
    api,
    map
  } = useMap(); // because I have 2 ;-), doesnt matter here, will be set before 1st usage

  const pixelRatioRef = useRef(2); // $FlowFixMe no block level $FlowFixMe so splitted on 2 lines

  const anyChildren = Children.toArray(props.children || []);
  const children = anyChildren;
  const [overlay, setOverlay] = useState(null);
  const childrenRef = useRef([]);
  const childrenDivRefs = useRef([]);

  const subPixelRound = v => Math.round(v * pixelRatioRef.current) / pixelRatioRef.current; // We can't use useEffect here because it causes glitches
  // We need ref to access children in draw


  useLayoutEffect(() => {
    childrenRef.current = children;
  }); // Create overlay https://developers.google.com/maps/documentation/javascript/examples/overlay-simple

  useEffect(() => {
    if (api) {
      pixelRatioRef.current = window.devicePixelRatio;
      const overlayView = new api.OverlayView();
      let elt = null;

      overlayView.onAdd = () => {
        elt = document.createElement('div');
        var panes = overlayView.getPanes(); // on all other panes there is issues with events like hover etc

        panes.floatPane.appendChild(elt);
        setOverlay({
          element: elt,
          view: overlayView
        });
      };

      overlayView.onRemove = () => {
        if (elt != null) {
          const {
            parentNode
          } = elt;

          if (parentNode != null) {
            // same as panes.overlayMouseTarget.removeChild
            parentNode.removeChild(elt);
          }

          setOverlay(null);
        }
      };

      overlayView.draw = () => {
        var projection = overlayView.getProjection();
        const latLngs = childrenRef.current;
        latLngs.forEach(({
          props: {
            lat,
            lng
          }
        }, index) => {
          const {
            current: childElt
          } = childrenDivRefs.current[index];

          if (childElt != null) {
            const pos = projection.fromLatLngToDivPixel(new api.LatLng(lat, lng)); // Move react markers directly changing dom element position
            // Element is created by us, not by library user, so no issues

            childElt.style.left = subPixelRound(pos.x) + 'px';
            childElt.style.top = subPixelRound(pos.y) + 'px';
          }
        });
      };

      overlayView.setMap(map);
      return () => {
        overlayView.setMap(null);
      };
    }
  }, [api, map]);

  if (overlay != null && children != null && api != null) {
    const projection = overlay.view.getProjection();
    return createPortal(children.map((ch, index) => {
      const pos = projection.fromLatLngToDivPixel(new api.LatLng(ch.props.lat, ch.props.lng)); // Its not a side effect, its just a cache for refs
      // instead of creating it initially like Array(MAX_POSSIBLE_MARKERS), we just extend it here

      if (childrenDivRefs.current[index] == null) {
        childrenDivRefs.current[index] = {
          current: null
        };
      }

      return /*#__PURE__*/createElement("div", {
        key: ch.key,
        ref: childrenDivRefs.current[index],
        style: {
          position: 'absolute',
          left: subPixelRound(pos.x),
          top: subPixelRound(pos.y),
          display: 'grid',
          gridTemplate: '0/0'
        }
      }, ch, (process.env.NODE_ENV !== 'production' || undefined === 'true') && props.debug === true && /*#__PURE__*/createElement("div", {
        style: {
          position: 'absolute',
          borderRadius: '100%',
          width: 4,
          height: 4,
          left: -2,
          top: -2,
          opacity: 0.8,
          boxShadow: '0 0 0 2px blue, 0 0 0 4px white, 0 0 0 6px blue'
        }
      }));
    }), overlay.element);
  }

  return null;
};

export { Map, Marker, Overlay, useMap };
